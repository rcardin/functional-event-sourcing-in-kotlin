/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package `in`.rcard.fes

import arrow.core.Either
import arrow.core.NonEmptyList
import arrow.core.nonEmptyListOf
import arrow.core.raise.either
import arrow.core.toNonEmptyListOrNull
import `in`.rcard.fes.portfolio.Portfolio
import `in`.rcard.fes.portfolio.PortfolioCommand
import `in`.rcard.fes.portfolio.PortfolioCommand.CreatePortfolio
import `in`.rcard.fes.portfolio.PortfolioCommand.PortfolioCommandWithPortfolioId.BuyStocks
import `in`.rcard.fes.portfolio.PortfolioCommand.PortfolioCommandWithPortfolioId.ClosePortfolio
import `in`.rcard.fes.portfolio.PortfolioCommand.PortfolioCommandWithPortfolioId.SellStocks
import `in`.rcard.fes.portfolio.PortfolioError
import `in`.rcard.fes.portfolio.PortfolioError.PortfolioIsClosed
import `in`.rcard.fes.portfolio.PortfolioError.PortfolioNotAvailable
import `in`.rcard.fes.portfolio.PortfolioError.PriceNotAvailable
import `in`.rcard.fes.portfolio.PortfolioEvent
import `in`.rcard.fes.portfolio.PortfolioEvent.PortfolioClosed
import `in`.rcard.fes.portfolio.PortfolioEvent.StocksSold
import `in`.rcard.fes.portfolio.PortfolioId
import `in`.rcard.fes.portfolio.availableFunds
import `in`.rcard.fes.portfolio.id
import `in`.rcard.fes.portfolio.isAvailable
import `in`.rcard.fes.portfolio.isClosed
import `in`.rcard.fes.portfolio.notCreatedPortfolio
import `in`.rcard.fes.portfolio.ownedStocks
import java.time.Clock

context (Clock, PortfolioEventStore)
fun handle(command: PortfolioCommand): Either<PortfolioError, PortfolioId> = either {
    when (command) {
        is PortfolioCommand.PortfolioCommandWithPortfolioId -> {
            val (eTag, portfolio) = loadState(command.portfolioId)
            val events = decide(command, portfolio).bind()
            val newPortfolio = events.fold(portfolio) { currentPortfolio, event -> evolve(currentPortfolio, event) }
            if (!saveState(command.portfolioId, eTag, newPortfolio)) {
                handle(command)
            }
            command.portfolioId
        }

        else -> {
            val events = decide(command, notCreatedPortfolio).bind()
            val newPortfolio =
                events.fold(notCreatedPortfolio) { currentPortfolio, event -> evolve(currentPortfolio, event) }
            saveState(newPortfolio.id, newPortfolio)
            newPortfolio.id
        }
    }
}

context(Clock)
fun decide(command: PortfolioCommand, portfolio: Portfolio): Either<PortfolioError, NonEmptyList<PortfolioEvent>> =
    when (command) {
        is CreatePortfolio -> createPortfolio(portfolio, command)
        is BuyStocks -> buyStocks(portfolio, command)
        is SellStocks -> sellStocks(portfolio, command)
        is ClosePortfolio -> closePortfolio(portfolio, command)
    }

context(Clock)
private fun createPortfolio(
    portfolio: Portfolio,
    command: CreatePortfolio,
) = either {
    if (portfolio.isAvailable()) {
        raise(PortfolioError.PortfolioAlreadyExists(portfolio.id))
    }
    nonEmptyListOf(
        PortfolioEvent.PortfolioCreated(
            PortfolioId("${command.userId}-1"),
            this@Clock.millis(),
            command.userId,
            command.amount,
        ),
    )
}

context(Clock)
private fun buyStocks(
    portfolio: Portfolio,
    command: BuyStocks,
): Either<PortfolioError, NonEmptyList<PortfolioEvent>> = either {
    if (!portfolio.isAvailable()) {
        raise(PortfolioNotAvailable(command.portfolioId))
    }
    if (portfolio.isClosed()) {
        raise(PortfolioIsClosed(command.portfolioId))
    }
    val requestedFundsForStocks = command.price * command.quantity
    val availableFunds = portfolio.availableFunds()
    if (availableFunds < requestedFundsForStocks) {
        raise(PortfolioError.InsufficientFunds(portfolio.id, requestedFundsForStocks, availableFunds))
    }
    nonEmptyListOf(
        PortfolioEvent.StocksPurchased(
            command.portfolioId,
            this@Clock.millis(),
            command.stock,
            command.quantity,
            command.price,
        ),
    )
}

context(Clock)
private fun sellStocks(
    portfolio: Portfolio,
    command: SellStocks,
): Either<PortfolioError, NonEmptyList<PortfolioEvent>> = either {
    if (portfolio.isClosed()) {
        raise(PortfolioIsClosed(command.portfolioId))
    }
    val ownedStocks = portfolio.ownedStocks(command.stock)
    if (ownedStocks < command.quantity) {
        raise(
            PortfolioError.NotEnoughStocks(
                portfolio.id,
                command.stock,
                command.quantity,
                ownedStocks,
            ),
        )
    }

    nonEmptyListOf(
        StocksSold(
            command.portfolioId,
            this@Clock.millis(),
            command.stock,
            command.quantity,
            command.price,
        ),
    )
}

context(Clock)
fun closePortfolio(
    portfolio: Portfolio,
    command: ClosePortfolio,
): Either<PortfolioError, NonEmptyList<PortfolioEvent>> = either {
    if (portfolio.isClosed()) {
        raise(PortfolioIsClosed(command.portfolioId))
    }
    val stocksSoldEvents: List<StocksSold> = portfolio.ownedStocks().map {
        StocksSold(
            command.portfolioId,
            this@Clock.millis(),
            it.stock,
            it.quantity,
            command.prices[it.stock] ?: raise(
                PriceNotAvailable(command.portfolioId, it.stock),
            ),
        )
    }
    (stocksSoldEvents + PortfolioClosed(command.portfolioId, this@Clock.millis())).toNonEmptyListOrNull()
        ?: nonEmptyListOf(
            PortfolioClosed(
                command.portfolioId,
                this@Clock.millis(),
            ),
        )
}

fun evolve(portfolio: Portfolio, event: PortfolioEvent): Portfolio = portfolio + event

typealias ETag = String

typealias LoadedPortfolio = Pair<ETag, Portfolio>

class PortfolioEventStore {

    fun loadState(portfolioId: PortfolioId): LoadedPortfolio =
        TODO() // Either<EventStoreError, LoadedPortfolio>

    fun saveState(portfolioId: PortfolioId, eTag: ETag, portfolio: Portfolio): Boolean =
        TODO() // Either<EventStoreError, Unit>

    fun saveState(portfolioId: PortfolioId, portfolio: Portfolio): Boolean =
        TODO() // Either<EventStoreError, Unit>

    sealed interface EventStoreError {
        data class StateLoadingError(val portfolioId: PortfolioId) : EventStoreError
        data class ConcurrentModificationError(val portfolioId: PortfolioId) : EventStoreError
        data class StateSavingError(val portfolioId: PortfolioId) : EventStoreError
    }
}

fun main() {
    println("Hello World!")
}
